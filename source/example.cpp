// This software is in the public domain. Where that dedication is not
// recognized, you are granted a perpetual, irrevocable license to copy,
// distribute, and modify this file as you see fit.
// Authored in 2015 by Dimitri Diakopoulos (http://www.dimitridiakopoulos.com)
// https://github.com/ddiakopoulos/tinyply

#include <thread>
#include <chrono>
#include <vector>
#include <sstream>
#include <fstream>
#include <iostream>
#include <random>

class UniformRandomGenerator
{
	std::random_device rd;
	std::mt19937_64 gen;
	std::uniform_real_distribution<float> full{ 0.f, 1.f };
public:
	UniformRandomGenerator() : rd(), gen(rd()) { }
	float random_float() { return full(gen); }
	int random_int(int max) { std::uniform_int_distribution<int> dInt(0, max); return dInt(gen); }
};

#include "tinyply.h"

using namespace tinyply;

typedef std::chrono::time_point<std::chrono::high_resolution_clock> timepoint;
std::chrono::high_resolution_clock c;

inline std::chrono::time_point<std::chrono::high_resolution_clock> now()
{
	return c.now();
}

inline double difference_micros(timepoint start, timepoint end)
{
	return (double)std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
}

UniformRandomGenerator gen;

void write_ply_example(const std::string & filename)
{
	PLY_SCOPED_TIMER("Write Example");

	std::vector<float> verts;
	std::vector<float> norms;
	std::vector<int32_t> vertexIndicies;

	// Per-vertex elements
	for (int i = 0; i < 262144 / 3; ++i)
	{
		verts.push_back(gen.random_float());
		norms.push_back(gen.random_float());
		vertexIndicies.push_back(gen.random_int(32768));
	}

	// Tinyply does not perform any file i/o internally
	std::filebuf fb;
	fb.open(filename, std::ios::out | std::ios::binary);
	std::ostream outputStream(&fb);

	PlyFile myFile;

	myFile.add_properties_to_element("vertex", { "x", "y", "z" }, verts);
	myFile.add_properties_to_element("vertex", { "nx", "ny", "nz" }, norms);

	// List property types must also be created with a count and type of the list (data property type
	// is automatically inferred from the type of the vector argument). 
	myFile.add_properties_to_element("face", { "vertex_indices" }, vertexIndicies, 3, PlyProperty::Type::UINT8);

	myFile.comments.push_back("generated by tinyply");

	{
		//PLY_SCOPED_TIMER(".write() binary");
		myFile.write(outputStream, true);
	}

	fb.close();
}

int main(int argc, char *argv[])
{


	write_ply_example("example_bigfile.ply");

	/*
	const size_t bufsize = 1024 * 1024;
	{ 
		PLY_SCOPED_TIMER(".write() example github");
		PlyFile ply;
		std::fstream outputStream("file.ply.junk", std::fstream::out | std::fstream::binary | std::fstream::trunc);
		// set up buffering
		// const size_t bufsize = 1024 * 1024;
		char* buf = (char*)malloc(bufsize);
		outputStream.rdbuf()->pubsetbuf(buf, bufsize);
		std::cout << "Writing to disk... Buffer size is: " << bufsize << " bytes\n";
		auto start = std::chrono::high_resolution_clock::now();
		ply.write(outputStream, true);
		auto duration = (std::chrono::duration_cast<std::chrono::milliseconds>( std::chrono::high_resolution_clock::now() - start).count());
		std::cout << "Closing file... Took " << duration << " ms\n";
		free(buf);
		outputStream.close();
	}
	*/

	/*
	{
		PLY_SCOPED_TIMER("speedtest");

		std::vector<uint8_t> buffer;
		for (int i = 0; i < 32768 * 128 * 20 * 16; ++i) // 1gb
		{
			buffer.push_back(i);
		}

		// test for speedz
		{
			int64_t total = 0;
			std::ofstream myfile("file.binary", std::ios::out | std::ios::binary);
			// write to outfile
			myfile.write((char *)buffer.data(), buffer.size());
			myfile.close();
		}
	}
	*/

	std::this_thread::sleep_for(std::chrono::seconds(5));

	return 0;
}
